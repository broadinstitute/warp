package org.broadinstitute.dsp.pipelines.tester

import java.net.URL
import java.time.ZoneId

import akka.actor.ActorSystem
import akka.stream.ActorMaterializer
import better.files.File
import io.circe.Json
import io.circe.generic.extras.Configuration
import io.circe.parser.parse
import org.broadinstitute.clio.client.webclient.ClioWebClient
import org.broadinstitute.clio.transfer.model.{IndexKey, Metadata}
import org.broadinstitute.dsp.pipelines.file.TsvParser
import org.broadinstitute.dsp.pipelines.firecloud.FireCloudClient
import org.broadinstitute.dsp.pipelines.firecloud.model.autogen.Workspace
import org.broadinstitute.dsp.pipelines.firecloud.model.{
  AttributeValue,
  EntityReference,
  FireCloudEntity,
  SampleSetEntity
}
import org.broadinstitute.dsp.pipelines.inputs.FireCloudWdlInputs
import org.broadinstitute.dsp.pipelines.util.DateFormatters.FireCloudWorkspaceDateFormatters

import scala.collection.immutable
import scala.concurrent.Future
import scala.util.{Failure, Success, Try}

abstract class FireCloudDeliveryTester[K <: IndexKey, M <: Metadata[M]](
    implicit am: ActorMaterializer,
    as: ActorSystem,
) extends CromwellWorkflowTester {

  def inputsDir: File

  def wdlInputsDecoded: FireCloudWdlInputs
  def differentiator: String

  def readKeys(): Seq[K]

  def workflowTimezoneId: ZoneId

  protected lazy val clioWebClient = ClioWebClient(
    credentials = googleCredentials,
    clioHost = "clio.gotc-dev.broadinstitute.org",
    clioPort = 443,
    useHttps = true
  )

  lazy val fireCloudClient: FireCloudClient = new FireCloudClient(
    new URL("https://api.firecloud.org/"),
    wdlInputsDecoded.billingProject,
    wdlInputsDecoded.workspaceName,
    googleCredentials
  )

  def preparedMetadata: M

  def cleanupFireCloudWorkspace(
      keys: Iterable[K],
      moved: Iterable[Future[Try[Unit]]]
  ): Future[Unit] = {
    val folded =
      Future.foldLeft(moved.to[immutable.Seq])(Seq.empty[Throwable]) {
        (acc: Seq[Throwable], attempt: Try[Unit]) =>
          attempt match {
            case Success(_)  => acc
            case Failure(ex) => acc :+ ex
          }
      }

    folded.flatMap { seq =>
      if (seq.isEmpty) {
        fireCloudClient.getWorkspace.transformWith {
          case Success(_) =>
            fireCloudClient.deleteWorkspace
              .recover {
                case ex =>
                  throw new RuntimeException(
                    s"Failed to delete firecloud workspace at ${fireCloudClient.existingWorkspaceEndpoint}",
                    ex
                  )
              }
              .map { _ =>
                logger.info(
                  s"Successfully removed firecloud workspace at ${fireCloudClient.existingWorkspaceEndpoint}"
                )
              }
          case Failure(_) =>
            logger.warn(
              "The firecloud workspace doesn't seem to exist. Skipping.")
            Future.unit
        }
      } else {
        val mapped = keys.map { key =>
          s"${key.toString} is moved back to the same location as its params_file"
        }
        Future.failed(
          new RuntimeException(
            s"""Not all clio resources were moved back to their original location. Please make sure:
               |${mapped.mkString("\n")}""".stripMargin,
            seq.head
          )
        )
      }
    }
  }

  /**
    * Verify that the workflow did what was expected.
    * This method checks that the workspace properties, samples, sample sets,
    * participants, and tags are all what is expected
    * @return Success or Failure based on test
    */
  def verifyWorkflow(fireCloudBucket: String): Future[Unit] = {
    logger.info("Verifying the workflow and its properties")
    for {
      workspace <- fireCloudClient.getWorkspace.map(_.workspace)
      // Check all the workspace properties
      _ <- Future.fromTry(checkWorkspaceProperties(workspace))
      _ = logger.info("Verifying samples in the FireCloud workspace")
      // Samples generated by the test
      samples <- fireCloudClient.getWorkspaceSamples
      // Expected samples
      samplesTsv = TsvParser.parseFromInput(
        inputsDir / "expected" / "samples.tsv",
        transformExpected(_).replace("{FC_BUCKET}", fireCloudBucket)
      )
      // Check test samples against expected samples
      _ <- Future.fromTry(
        checkEntities(samples, samplesTsv, "entity:sample_id"))
      _ = logger.info("Verifying participants in the FireCloud workspace")
      // Participants generated by the test
      participants <- fireCloudClient.getWorkspaceParticipants
      // Expected participants
      participantsTsv = TsvParser.parseFromInput(
        inputsDir / "expected" / "participants.tsv",
        transformExpected(_)
      )
      // Check test participants against expected participants
      _ <- Future.fromTry(
        checkEntities(participants, participantsTsv, "entity:participant_id")
      )
      _ = logger.info("Verifying sample sets in the FireCloud workspace")
      // Sample sets generated by the test
      workspaceSampleSets <- fireCloudClient.getWorkspaceSampleSets
      // Expected Sample sets
      sampleSetEntities = TsvParser.parseFromInput(
        inputsDir / "expected" / "sample_set_entity.tsv",
        transformExpected(_).replace("{FC_BUCKET}", fireCloudBucket)
      )
      // Expected sample set membership
      sampleSetMembership = TsvParser.parseFromInput(
        inputsDir / "expected" / "sample_set_membership.tsv",
        transformExpected(_)
      )
      // Check the test sample sets against the expected values
      _ <- Future.fromTry(
        checkSampleSets(workspaceSampleSets,
                        sampleSetEntities,
                        sampleSetMembership)
      )
    } yield {
      // Oh joyous day!
      logger.info("All verification tests have passed. Yippee!")
    }
  }

  // Needs to be here to override the configuration from ModelAutoDerivation
  // which specifies snake_case variable names.
  implicit override val jsonConfig: Configuration = Configuration.default

  /**
    * Check the properties of the workspace to see if the match the expected
    * @param workspace Workspace retrieved from FireCloud
    * @return Successful or failed Future based on testing
    */
  private[tester] def checkWorkspaceProperties(
      workspace: Workspace): Try[Unit] = {
    logger.info("Verifying that workspace name is set to the billing project")
    for {
      _ <- assertEqual(
        workspace.namespace,
        wdlInputsDecoded.billingProject,
        "workspace namespace"
      )
      _ = logger.info("Verifying that the workspace name is correct")
      _ <- assertEqual(workspace.name,
                       wdlInputsDecoded.workspaceName,
                       "workspace name")
      libraryAttrsExpected <- jsonFromInputs(
        inputsDir / "expected" / "libAttrs.json",
        transformExpected
      )
      workspaceTagsExpectedParsed <- jsonFromInputs(
        inputsDir / "expected" / "tags.json",
        transformExpected
      )
      workspaceTagsExpected <- workspaceTagsExpectedParsed.as[Seq[String]].toTry
      _ = logger.info("Verifying that workspace library attributes are correct")
      _ <- checkWorkspaceAttributes(workspace, libraryAttrsExpected)
      _ = logger.info("Verifying that workspace tags are correct")
      _ <- checkWorkspaceTags(workspace, workspaceTagsExpected)
    } yield ()
  }

  /**
    * Check that workspace attributes are uploaded correctly in to FireCloud
    * @param workspace Workspace from FireCloud to test
    * @param libAttrsJson Expected Library Attributes
    * @return Successful or failed Future based on testing
    */
  private[tester] def checkWorkspaceAttributes(
      workspace: Workspace,
      libAttrsJson: Json
  ): Try[Unit] = {

    val libAttrsObject = libAttrsJson.asObject.toRight {
      new RuntimeException(
        s"Expected a JSON object for workspace attributes, got: ${libAttrsJson.spaces2}"
      )
    }
    libAttrsObject.toTry.flatMap { obj =>
      val errors = obj.toList.foldLeft(Seq.empty[Throwable]) {
        case (errs, (key, value)) =>
          val assertion =
            if (value.isArray) {
              val workspaceAttrValue = workspace
                .attributes(key)
                .as[AttributeValue[Seq[String]]]
                .left
                .map { e =>
                  new RuntimeException(
                    s"Could not decode $key from returned workspace attributes",
                    e
                  )
                }
                .toTry
              val expectedAttrValue = value
                .as[Seq[String]]
                .left
                .map { e =>
                  new RuntimeException(
                    s"Could not decode $key from expected workspace attributes",
                    e
                  )
                }
                .toTry

              for {
                actual <- workspaceAttrValue
                expected <- expectedAttrValue
                _ <- assertEqual(
                  actual.items.toSet,
                  expected.toSet,
                  s"workspace attributes for $key"
                )
              } yield {
                ()
              }
            } else {
              assertEqual(
                workspace.attributes(key),
                value,
                s"workspace attribute for $key"
              )
            }

          assertion match {
            case Success(_)   => errs
            case Failure(err) => errs :+ err
          }
      }

      if (errors.isEmpty) {
        Success(())
      } else {
        val err =
          s"""Errors found while checking workspace metadata:
             |${errors.mkString("\n")}
           """.stripMargin
        Failure(new CromwellWorkflowTester.TestFailedException(err))
      }
    }
  }

  /**
    * Check that workspace tags are uploaded correctly in FireCloud
    * @param workspace Workspace from FireCloud to test
    * @param tags Expected tags
    * @return Successful or failed Future based on testing
    */
  private[tester] def checkWorkspaceTags(
      workspace: Workspace,
      tags: Seq[String]
  ): Try[Unit] =
    workspace
      .attributes("tag:tags")
      .as[AttributeValue[Seq[String]]]
      .map(workspaceAttrs => tags.forall(workspaceAttrs.items.contains))
      .fold(
        ex =>
          Failure(new RuntimeException("Failed to decode workspace tags", ex)),
        _ => Success(())
      )

  /**
    * Check that entities are uploaded correctly to FireCloud
    * @param entities Entities from FireCloud
    * @param entitiesTsv Expected Entities in Tsv form
    * @param nameField name of the field in workspace entities to test
    * @return Successful or failed Future based on testing
    */
  private[tester] def checkEntities(
      entities: Seq[FireCloudEntity],
      entitiesTsv: Seq[Map[String, String]],
      nameField: String
  ): Try[Unit] = {
    assertEqual(entities.size, entitiesTsv.size, "number of uploaded entities")
      .flatMap { _ =>
        val errors = entitiesTsv.foldLeft(Seq.empty[Throwable]) { (errs, row) =>
          val assertion = for {
            entity <- entities
              .find(_.name == row(nameField))
              .toRight {
                val err =
                  s"No entity with name ${row(nameField)} returned from the workflow"
                new CromwellWorkflowTester.TestFailedException(err)
              }
              .toTry
            _ <- checkEntity(entity, row)
          } yield {
            ()
          }

          assertion match {
            case Success(_)   => errs
            case Failure(err) => errs :+ err
          }
        }

        if (errors.isEmpty) {
          Success(())
        } else {
          val err =
            s"""Errors found while checking workspace entities:
               |${errors.mkString("\n")}
           """.stripMargin
          Failure(new CromwellWorkflowTester.TestFailedException(err))
        }
      }
  }

  /**
    * Check an individual entity for correctness
    * @param workspaceEntity Workspace entity to test
    * @param tsvEntity The expected entity in Map[String, String] form
    * @return Successful or failed Future based on testing
    */
  private def checkEntity(
      workspaceEntity: FireCloudEntity,
      tsvEntity: Map[String, String]
  ): Try[Unit] = {
    val errors = workspaceEntity.attributes.foldLeft(Seq.empty[Throwable]) {
      case (errs, (key, value)) =>
        assertEqual(value, tsvEntity(key), s"workspace entity for $key") match {
          case Success(_)   => errs
          case Failure(err) => errs :+ err
        }
    }

    if (errors.isEmpty) {
      Success(())
    } else {
      val err =
        s"""Errors found while checking entity attributes:
           |${errors.mkString("\n")}
         """.stripMargin
      Failure(new CromwellWorkflowTester.TestFailedException(err))
    }
  }

  /**
    * Check that sample sets were correctly uploaded to FireCloud
    * @param workspaceSampleSets Sample sets from the FireCloud workspace
    * @param sampleSetEntities Expected sample set entities in Tsv form
    * @param sampleSetMembership Expected sample set membership in Tsv form
    * @return Successful or failed Future based on testing
    */
  private[tester] def checkSampleSets(
      workspaceSampleSets: Seq[SampleSetEntity],
      sampleSetEntities: Seq[Map[String, String]],
      sampleSetMembership: Seq[Map[String, String]]
  ): Try[Unit] = {

    val expectedSampleSets: Seq[SampleSetEntity] = sampleSetEntities.map { m =>
      SampleSetEntity(
        name = m("entity:sample_set_id"),
        entityType = "sample_set",
        samples = sampleSetMembership
          .filter { ssm =>
            ssm("membership:sample_set_id")
              .equals(m("entity:sample_set_id"))
          }
          .map(ssm => EntityReference("sample", ssm("sample_id")))
          .toSet,
        attributes = m - "entity:sample_set_id"
      )
    }
    assertEqual(workspaceSampleSets,
                expectedSampleSets,
                "workspace sample sets")
  }

  protected def transformExpected(line: String): String = {
    line
      .replaceAllLiterally("{DIFF}", differentiator)
      .replaceAllLiterally("{REQUESTER}", wdlInputsDecoded.requester)
      .replace(
        "{WORKSPACE_DATE}",
        FireCloudWorkspaceDateFormatters.dateForTags(workflowTimezoneId)
      )
      .replace("{DATE}",
               FireCloudWorkspaceDateFormatters.dateForTsv(workflowTimezoneId))
  }

  private def jsonFromInputs(
      path: File,
      transform: String => String
  ): Try[Json] = {
    parse(path.lines.map(transform).mkString).toTry
  }

}
